---
title: "Sim_ABCRF"
author: "LEJEUNE Thomas"
date: "`r Sys.Date()`"
output: html_document
runtime: shiny
---

```{r = Packages generation} 

library(tidyverse)
library(abcrf)
library(ggplot2)
library(tinytex)
library(dplyr)
library(openxlsx)

```

```{r = Setting working directory}
# Desktop detection
home_path <- Sys.getenv("HOME")

desktop_path <- if (dir.exists(file.path(home_path, "Desktop"))) {
  file.path(home_path, "Desktop")
} else if (dir.exists(file.path(home_path, "Bureau"))) {
  file.path(home_path, "Bureau")
} else {
  stop
}

# Complete path
file_path_data <- file.path("C:/Users/poupe/simulations/data_model.csv")

# Reading file
data <- read_csv(file_path_data)

```

```{r = Hard cleaning (Column removal - Automatic version)}

# Function that will search every column and count the "NA", then remove the columns having too much missing values according to the threshold
remove_high_na_cols <- function(data, threshold = 0.01) {
  total_rows <- nrow(data)
  na_summary <- data %>%
    summarise(across(everything(), ~ sum(is.na(.)))) %>%
    pivot_longer(cols = everything(), names_to = "Variable", values_to = "NA_count") %>%
    mutate(
      Total_rows = total_rows,
      NA_percentage = round((NA_count / Total_rows) * 100, 2)
    )
  cols_to_remove <- na_summary %>%
    filter(NA_percentage > threshold * 100) %>%
    pull(Variable)
  data_clean <- data %>% select(-any_of(cols_to_remove))
  list(data_clean = data_clean, removed = cols_to_remove, na_summary = na_summary)
}
result <- remove_high_na_cols(data, threshold = 0.05)
data_clean <- result$data 
result$na_summary  # List of removed col

top_n_display <- 20

ggplot(result$na_summary %>% 
         filter(NA_percentage > 0) %>% 
         slice_max(NA_percentage, n = top_n_display),
       aes(x = reorder(Variable, -NA_percentage), y = NA_percentage)) +
  geom_col(fill = "steelblue") +
  coord_flip() +
  labs(
    title = "Top 30 variables with most NA",
    x = "Resuming stats",
    y = "NA percentage (%)"
  ) +
  theme_minimal(base_size = 14)

```

```{r}
# Fusionner les colonnes à retirer
cols_to_remove <- c(
  # Ne stats
  "P_Ne_0.050", "P_Ne_0.020", "P_Ne_0.010", "P_Ne_0.000",
  "N_Ne_0.050", "N_Ne_0.020", "N_Ne_0.010", "N_Ne_0.000",
  "J_Ne_0.050", "J_Ne_0.020", "J_Ne_0.010", "J_Ne_0.000",

  # census_N et batch
  "census_N_1", "census_N_2", "census_N_3", "census_N_4", 
  "census_N_5", "census_N_6", "census_N_7", "census_N_8",
  "census_N_9", "census_N_10", "census_N_11",
  "batch",

  # Historic genetic stats
  "mean_alleles_pop1", "mean_alleles_pop2",
  "sum_alleles_pop1", "sum_alleles_pop2",
  "mean_exp_het_pop1", "mean_exp_het_pop2",
  "mean_obs_het_pop1", "mean_obs_het_pop2",
  "var_alleles_pop1", "var_alleles_pop2"
)

# Supprimer les colonnes et lignes avec au moins un NA
data_clean <- data_clean %>% 
  select(-any_of(cols_to_remove)) %>%
  na.omit()

```

```{r}
# 1. Sélectionner les colonnes MatchCount
matchcount_cols <- grep("MatchCount", names(data_clean), value = TRUE)

# 2. Calculer la moyenne et la variance ligne par ligne
data_clean$MatchCount_mean <- rowMeans(data_clean[, matchcount_cols], na.rm = TRUE)
data_clean$MatchCount_var  <- apply(data_clean[, matchcount_cols], 1, var, na.rm = TRUE)

# Conserver uniquement la première et la dernière
#cols_to_keep <- c(matchcount_cols[1], tail(matchcount_cols, 1))

# Conserver aussi toutes les autres colonnes ne contenant pas "MatchCount"
other_cols <- setdiff(names(data_clean), matchcount_cols)

# Créer le nouveau dataframe avec les bonnes colonnes
data_clean <- data_clean[,other_cols]
#data_clean <- data_clean[, c(other_cols, cols_to_keep)]
```

```{r}
# Étape 1 : Extraire toutes les colonnes Realized_Ne_*
ne_cols <- grep("^Realized_Ne_", names(data_clean), value = TRUE)

# Étape 2 : Calcul de la moyenne harmonique
harmonic_mean <- function(x) {
  x <- as.numeric(x)
  x <- x[!is.na(x) & x > 0]
  if (length(x) == 0) return(NA)
  return(length(x) / sum(1 / x))
}

# Appliquer la fonction à chaque ligne
data_clean$Harmonic_Ne <- apply(data_clean[, ne_cols], 1, harmonic_mean)

# Étape 3 : Calcul du ratio Ne/N
if ("pop_size" %in% colnames(data_clean)) {
  data_clean$Ne_N_ratio <- data_clean$Harmonic_Ne / data_clean$pop_size
} else {
  warning("Colonne 'pop_size' manquante : ratio Ne/N non calculé.")
}

```

```{r}
data_clean <- na.omit(data_clean)
```

```{r = Set the parameters and resuming statistics tables}

# List of parameters
param_cols <- c("simulation_id", "pop_size", "num_loci", "sample1_size_Ne", "sample2_size_Ne",
                "sample_size_CMR", "mutation_rate", "recap_Ne", "Harmonic_Ne", "Ne_N_ratio")
params <- data_clean %>% select(all_of(param_cols))

# List of resuming statistics
stat_keywords <- c("id", "LD", "HE", "Coan", "het", "alleles", "P_", "N_F", "J_", "MatchCount_", "Reprodcutive_")
stat_cols <- names(data_clean)[sapply(names(data_clean), function(col) any(str_detect(col, stat_keywords)))]
stats_table <- data_clean %>% select(all_of(stat_cols))

```

```{r = ABCRF model - pop_size}

# Choose the parameter that will be predicted and create a new dataframe with it in the first column and the resuming stats
target_param_N <- "pop_size"
learning_data_N <- bind_cols(y = params[[target_param_N]], stats_table) %>% rename(!!target_param_N := y)

# Regression ABCRF that will predict the values of a parameters from the data base formed by the simulations
model_rf_N <- regAbcrf(as.formula(paste(target_param_N, "~ .")), data = learning_data_N, ntree = 100)
summary(model_rf_N)

```

```{r = ABCRF model - Reailized_Ne}

# Choose the parameter that will be predicted and create a new dataframe with it in the first column and the resuming stats
target_param_Ne <- "Harmonic_Ne"
learning_data_Ne <- bind_cols(y = params[[target_param_Ne]], stats_table) %>% rename(!!target_param_Ne := y)

# Regression ABCRF that will predict the values of a parameters from the data base formed by the simulations
model_rf_Ne <- regAbcrf(as.formula(paste(target_param_Ne, "~ .")), data = learning_data_Ne, ntree = 100)
summary(model_rf_Ne)

```

```{r = ABCRF model - Ne_N_ratio}

# Choose the parameter that will be predicted and create a new dataframe with it in the first column and the resuming stats
target_param_Ne_N <- "Ne_N_ratio"
learning_data_Ne_N <- bind_cols(y = params[[target_param_Ne_N]], stats_table) %>% rename(!!target_param_Ne_N := y)

# Regression ABCRF that will predict the values of a parameters from the data base formed by the simulations
model_rf_Ne_N <- regAbcrf(as.formula(paste(target_param_Ne_N, "~ .")), data = learning_data_Ne_N, ntree = 100)
summary(model_rf_Ne_N)

```

```{r = Stat importance for ABCRF model - pop_size}

# Determines the order of importance of every resuming stat in the dataframe concerning the prediction of the parameter
importance_df_N <- model_rf_N$model.rf$variable.importance %>%
  sort(decreasing = TRUE) %>%
  enframe(name = "Statistic", value = "Importance")

# 2. Ne garder que les 20 premières variables
top_n <- 20
# Créer une variable de couleur
importance_top_N <- importance_df_N %>%
  mutate(color = ifelse(Statistic == "simulation_id", "highlight", "normal")) %>%
  mutate(Statistic = fct_reorder(Statistic, Importance)) %>%
  slice_max(order_by = Importance, n = top_n)

importance_top_N <- importance_top_N %>%
  mutate(color = ifelse(Statistic == "simulation_id", "highlight", "normal"))

# Graphique
ggplot(importance_top_N, aes(x = Statistic, y = Importance, fill = color)) +
  geom_col() +
  coord_flip() +
  scale_fill_manual(values = c("highlight" = "red", "normal" = "steelblue")) +
  labs(
    title = paste("Top", top_n, "most important variables for", target_param_N),
    x = "Statistics",
    y = "Importance (abcrf)"
  ) +
  theme_minimal(base_size = 14) +
  theme(legend.position = "none")

```

```{r = Stat importance for ABCRF model - Harmonic Ne}

# Determines the order of importance of every resuming stat in the dataframe concerning the prediction of the parameter
importance_df_Ne <- model_rf_Ne$model.rf$variable.importance %>%
  sort(decreasing = TRUE) %>%
  enframe(name = "Statistic", value = "Importance")

# 2. Ne garder que les 20 premières variables
top_n <- 20
# Créer une variable de couleur
importance_top_Ne <- importance_df_Ne %>%
  mutate(color = ifelse(Statistic == "simulation_id", "highlight", "normal")) %>%
  mutate(Statistic = fct_reorder(Statistic, Importance)) %>%
  slice_max(order_by = Importance, n = top_n)

importance_top_Ne <- importance_top_Ne %>%
  mutate(color = ifelse(Statistic == "simulation_id", "highlight", "normal"))

# Graphique
ggplot(importance_top_Ne, aes(x = Statistic, y = Importance, fill = color)) +
  geom_col() +
  coord_flip() +
  scale_fill_manual(values = c("highlight" = "red", "normal" = "steelblue")) +
  labs(
    title = paste("Top", top_n, "most important variables for", target_param_Ne),
    x = "Statistics",
    y = "Importance (abcrf)"
  ) +
  theme_minimal(base_size = 14) +
  theme(legend.position = "none")

```

```{r = Stat importance for ABCRF model - Ne_N_ratio}

# Determines the order of importance of every resuming stat in the dataframe concerning the prediction of the parameter
importance_df_Ne_N <- model_rf_Ne_N$model.rf$variable.importance %>%
  sort(decreasing = TRUE) %>%
  enframe(name = "Statistic", value = "Importance")

# 2. Ne garder que les 20 premières variables
top_n <- 20
# Créer une variable de couleur
importance_top_Ne_N <- importance_df_Ne_N %>%
  mutate(color = ifelse(Statistic == "simulation_id", "highlight", "normal")) %>%
  mutate(Statistic = fct_reorder(Statistic, Importance)) %>%
  slice_max(order_by = Importance, n = top_n)

importance_top_Ne_N <- importance_top_Ne_N %>%
  mutate(color = ifelse(Statistic == "simulation_id", "highlight", "normal"))

# Graphique
ggplot(importance_top_Ne_N, aes(x = Statistic, y = Importance, fill = color)) +
  geom_col() +
  coord_flip() +
  scale_fill_manual(values = c("highlight" = "red", "normal" = "steelblue")) +
  labs(
    title = paste("Top", top_n, "most important variables for", target_param_Ne_N),
    x = "Statistics",
    y = "Importance (abcrf)"
  ) +
  theme_minimal(base_size = 14) +
  theme(legend.position = "none")

```

```{r = Prediction values of the model}

# Use the model to make the predictions according to the "observed data" from the Out-Of-Bag "OOB"
predictions <- predict(model_rf, training = learning_data, obs = learning_data)$expectation

# Plotting the curve demonstrating the differences of the predictions of the dataframe studied with the target data from the Out-Of-Bag
plot(learning_data[[target_param]], predictions,
     xlab = "Real pop_size", ylab = "Predicted pop_size (OOB)",
     main = "Real vs prediction",
     pch = 20, col = "blue")
abline(0, 1, col = "red")

```

```{r}
plot(learning_data$pop_size, learning_data$MatchCount_var)
```

```{r prediction vs true value - pop_size}

# Créer un dataframe avec les vraies valeurs et les prédictions
prediction_df_N <- data.frame(
  pop_size = learning_data_N$pop_size,
  prediction = model_rf_N$model.rf$predictions
)

# Graphique ggplot
ggplot(prediction_df_N, aes(x = pop_size, y = prediction)) +
  geom_point(shape = 1, alpha = 0.6) +  # cercles ouverts et transparence
  geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed") +  # ligne identité
  scale_x_log10() +
  scale_y_log10() +
  labs(
    x = "True value (pop_size)",
    y = "Predicted value",
    title = "Prediction vs True values (abcrf)"
  ) +
  theme_minimal()

```

```{r prediction vs true value - Harmonic_Ne}

# Créer un dataframe avec les vraies valeurs et les prédictions
prediction_df_Ne <- data.frame(
  Harmonic_Ne = learning_data_Ne$Harmonic_Ne,
  prediction = model_rf_Ne$model.rf$predictions
)

# Graphique ggplot
ggplot(prediction_df_Ne, aes(x = Harmonic_Ne, y = prediction)) +
  geom_point(shape = 1, alpha = 0.6) +  # cercles ouverts et transparence
  geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed") +  # ligne identité
  scale_x_log10() +
  scale_y_log10() +
  labs(
    x = "True value (Harmonic_Ne)",
    y = "Predicted value",
    title = "Prediction vs True values (abcrf)"
  ) +
  theme_minimal()

```

```{r prediction vs true value - Ne_N_ratio}

# Créer un dataframe avec les vraies valeurs et les prédictions
prediction_df_Ne_N <- data.frame(
  Ne_N_ratio = learning_data_Ne_N$Ne_N_ratio,
  prediction = model_rf_Ne_N$model.rf$predictions
)

# Graphique ggplot
ggplot(prediction_df_Ne_N, aes(x = Ne_N_ratio, y = prediction)) +
  geom_point(shape = 1, alpha = 0.6) +  # cercles ouverts et transparence
  geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed") +  # ligne identité
  scale_x_log10() +
  scale_y_log10() +
  labs(
    x = "True value (Ne_N_ratio)",
    y = "Predicted value",
    title = "Prediction vs True values (abcrf)"
  ) +
  theme_minimal()

```

```{r}
res_oob_N <- predictOOB(object = model_rf_N, training = learning_data_N)

# Vraies valeurs
true_values_N <- learning_data_N$pop_size

# Prédictions
predicted_N <- res_oob_N$expectation

# RMSE
rmse_N <- sqrt(res_oob_N$MSE)

# Biais
bias_N <- mean(predicted_N - true_values_N)

# R²
r2_N <- 1 - sum((true_values_N - predicted_N)^2) / sum((true_values_N - mean(true_values_N))^2)

```

```{r}
res_oob_Ne <- predictOOB(object = model_rf_Ne, training = learning_data_Ne)

# Vraies valeurs
true_values_Ne <- learning_data_Ne$Harmonic_Ne

# Prédictions
predicted_Ne <- res_oob_Ne$expectation

# RMSE
rmse_Ne <- sqrt(res_oob_Ne$MSE)

# Biais
bias_Ne <- mean(predicted_Ne - true_values_Ne)

# R²
r2_Ne <- 1 - sum((true_values_Ne - predicted_Ne)^2) / sum((true_values_Ne - mean(true_values_Ne))^2)

```

```{r}
res_oob_Ne_N <- predictOOB(object = model_rf_Ne_N, training = learning_data_Ne_N)

# Vraies valeurs
true_values_Ne_N <- learning_data_Ne_N$Ne_N_ratio

# Prédictions
predicted_Ne_N <- res_oob_Ne_N$expectation

# RMSE
rmse_Ne_N <- sqrt(res_oob_Ne_N$MSE)

# Biais
bias_Ne_N <- mean(predicted_Ne_N - true_values_Ne_N)

# R²
r2_Ne_N <- 1 - sum((true_values_Ne_N - predicted_Ne_N)^2) / sum((true_values_Ne_N - mean(true_values_Ne_N))^2)

```

```{r}
# Sélection par nom exact pour les 2 premières colonnes
cols_fixed <- c("pop_size", "max_value")

# Sélection automatique des colonnes contenant 'Realized_Ne'
cols_realized <- grep("Realized_Ne", names(data), value = TRUE)

# Création d'un nouveau data frame avec ces colonnes uniquement
data_results <- data[, c(cols_fixed, cols_realized)]

write.xlsx(data_results, file = "C:/Users/poupe/simulations/selected_reference_data.xlsx", rowNames = FALSE)
 
```


