---
title: "Sim_ABCRF"
author: "LEJEUNE Thomas"
date: "`r Sys.Date()`"
output: html_document
runtime: shiny
---

```{r = Packages generation} 

library(tidyverse)
library(abcrf)
library(ggplot2)
library(tinytex)

```

```{r = Setting working directory}
# Desktop detection
home_path <- Sys.getenv("HOME")

desktop_path <- if (dir.exists(file.path(home_path, "Desktop"))) {
  file.path(home_path, "Desktop")
} else if (dir.exists(file.path(home_path, "Bureau"))) {
  file.path(home_path, "Bureau")
} else {
  stop
}

# Complete path
file_path <- file.path("C:/Users/poupe/simulations/summary_table_all_batches.csv")

# Reading file
data <- read_csv(file_path)

```

```{r = Hard cleaning (Column removal - Automatic version)}

# Function that will search every column and count the "NA", then remove the columns having too much missing values according to the threshold
remove_high_na_cols <- function(data, threshold = 0.01) {
  total_rows <- nrow(data)
  na_summary <- data %>%
    summarise(across(everything(), ~ sum(is.na(.)))) %>%
    pivot_longer(cols = everything(), names_to = "Variable", values_to = "NA_count") %>%
    mutate(
      Total_rows = total_rows,
      NA_percentage = round((NA_count / Total_rows) * 100, 2)
    )
  cols_to_remove <- na_summary %>%
    filter(NA_percentage > threshold * 100) %>%
    pull(Variable)
  data_clean <- data %>% select(-any_of(cols_to_remove))
  list(data_clean = data_clean, removed = cols_to_remove, na_summary = na_summary)
}
result <- remove_high_na_cols(data, threshold = 0.05)
data_clean <- result$data 
result$na_summary  # List of removed col

top_n_display <- 20

ggplot(result$na_summary %>% 
         filter(NA_percentage > 0) %>% 
         slice_max(NA_percentage, n = top_n_display),
       aes(x = reorder(Variable, -NA_percentage), y = NA_percentage)) +
  geom_col(fill = "steelblue") +
  coord_flip() +
  labs(
    title = "Top 30 variables with most NA",
    x = "Resuming stats",
    y = "NA percentage (%)"
  ) +
  theme_minimal(base_size = 14)

```

```{r}
data_clean <- data_clean %>%
  drop_na()
```

```{r}

# 1. Sélectionner les colonnes MatchCount
matchcount_cols <- grep("MatchCount", names(data_clean), value = TRUE)

# 2. Calculer la moyenne et la variance ligne par ligne
data_clean$MatchCount_mean <- rowMeans(data_clean[, matchcount_cols], na.rm = TRUE)
data_clean$MatchCount_var  <- apply(data_clean[, matchcount_cols], 1, var, na.rm = TRUE)

# Conserver uniquement la première et la dernière
#cols_to_keep <- c(matchcount_cols[1], tail(matchcount_cols, 1))

# Conserver aussi toutes les autres colonnes ne contenant pas "MatchCount"
other_cols <- setdiff(names(data_clean), matchcount_cols)

# Créer le nouveau dataframe avec les bonnes colonnes
data_clean <- data_clean[,other_cols]
#data_clean <- data_clean[, c(other_cols, cols_to_keep)]
```


```{r = Delete all Ne stats}

to_remove <- c(
  "P_Ne_0.050", "P_Ne_0.020", "P_Ne_0.010", "P_Ne_0.000",
  "N_Ne_0.050", "N_Ne_0.020", "N_Ne_0.010", "N_Ne_0.000",
  "J_Ne_0.050", "J_Ne_0.020", "J_Ne_0.010", "J_Ne_0.000", "census_N_1", "census_N_2","census_N_3", "census_N_4", "census_N_5", "census_N_6", "census_N_7", "census_N_8", "census_N_9", "census_N_10", "census_N_11", "batch"
)

# Remove the lines that contain at least one "NA"
data_clean <- data_clean %>% select(-any_of(to_remove)) %>% na.omit()

```

```{r = Delete the historic genetic stats}

to_remove <- c(
  "mean_alleles_pop1", "mean_alleles_pop2",
  "sum_alleles_pop1", "sum_alleles_pop2",
  "mean_exp_het_pop1", "mean_exp_het_pop2",
  "mean_obs_het_pop1", "mean_obs_het_pop2",
  "var_alleles_pop1", "var_alleles_pop2"
)

# Remove the lines that contain at least one "NA"
data_clean <- data_clean %>% select(-any_of(to_remove)) %>% na.omit()

```


```{r = Soft cleaning (Median)}

# Search every column for NA then calculate the median of the existing values and add it to the missing values
data_imputed <- data %>% mutate(across(everything(), ~ ifelse(is.na(.), median(., na.rm = TRUE), .)))

```

```{r = Hard cleaning (column removal - Classic version)}

# Hard version of the last method, choose the columns to delete to avoid suppressing too many lines while removing the NAs
to_remove <- c(
  "HE_Neb_mean_0.050_Pop2", "HE_Neb_mean_0.020_Pop2", "HE_Neb_mean_0.010_Pop2", "HE_Neb_mean_0.000_Pop2",
  "HE_Neb_mean_0.050_Pop1", "HE_Neb_mean_0.020_Pop1", "HE_Neb_mean_0.010_Pop1", "HE_Neb_mean_0.000_Pop1",
  "Coan_Neb_n_Pop1", "Coan_Neb_n_Pop2",
  "LD_Ne_0.050_Pop1", "LD_Ne_0.020_Pop1", "LD_Ne_0.010_Pop1", "LD_Ne_0.000_Pop1",
  "LD_Ne_0.050_Pop2", "LD_Ne_0.020_Pop2", "LD_Ne_0.010_Pop2", "LD_Ne_0.000_Pop2"
)

# Remove the lines that contain at least one "NA"
data <- data %>% select(-any_of(to_remove)) %>% na.omit()

```

```{r = Set the parameters and resuming statistics tables}

# List of parameters
param_cols <- c("simulation_id", "pop_size", "num_loci", "sample1_size_Ne", "sample2_size_Ne",
                "sample_size_CMR", "mutation_rate", "recap_Ne")
params <- data_clean %>% select(all_of(param_cols))

# List of resuming statistics
stat_keywords <- c("id", "LD", "HE", "Coan", "het", "alleles", "P_", "N_", "J_", "MatchCount_")
stat_cols <- names(data_clean)[sapply(names(data_clean), function(col) any(str_detect(col, stat_keywords)))]
stats_table <- data_clean %>% select(all_of(stat_cols))

```

```{r = ABCRF model}

# Choose the parameter that will be predicted and create a new dataframe with it in the first column and the resuming stats
target_param <- "pop_size"
learning_data <- bind_cols(y = params[[target_param]], stats_table) %>% rename(!!target_param := y)

# Regression ABCRF that will predict the values of a parameters from the data base formed by the simulations
model_rf <- regAbcrf(as.formula(paste(target_param, "~ .")), data = learning_data, ntree = 1000)
summary(model_rf)

```

```{r = Stat importance for ABCRF model}

# Determines the order of importance of every resuming stat in the dataframe concerning the prediction of the parameter
importance_df <- model_rf$model.rf$variable.importance %>%
  sort(decreasing = TRUE) %>%
  enframe(name = "Statistic", value = "Importance")

# 2. Ne garder que les 20 premières variables
top_n <- 20
# Créer une variable de couleur
importance_top <- importance_df %>%
  mutate(color = ifelse(Statistic == "simulation_id", "highlight", "normal")) %>%
  mutate(Statistic = fct_reorder(Statistic, Importance)) %>%
  slice_max(order_by = Importance, n = top_n)

importance_top <- importance_top %>%
  mutate(color = ifelse(Statistic == "simulation_id", "highlight", "normal"))

# Graphique
ggplot(importance_top, aes(x = Statistic, y = Importance, fill = color)) +
  geom_col() +
  coord_flip() +
  scale_fill_manual(values = c("highlight" = "red", "normal" = "steelblue")) +
  labs(
    title = paste("Top", top_n, "most important variables for", target_param),
    x = "Statistics",
    y = "Importance (abcrf)"
  ) +
  theme_minimal(base_size = 14) +
  theme(legend.position = "none")

```

```{r = Prediction values of the model}

# Use the model to make the predictions according to the "observed data" from the Out-Of-Bag "OOB"
predictions <- predict(model_rf, training = learning_data, obs = learning_data)$expectation

# Plotting the curve demonstrating the differences of the predictions of the dataframe studied with the target data from the Out-Of-Bag
plot(learning_data[[target_param]], predictions,
     xlab = "Real pop_size", ylab = "Predicted pop_size (OOB)",
     main = "Real vs prediction",
     pch = 20, col = "blue")
abline(0, 1, col = "red")

```

```{r}
plot(learning_data$pop_size, learning_data$MatchCount_var)
```

```{r}

# Créer un dataframe avec les vraies valeurs et les prédictions
prediction_df <- data.frame(
  pop_size = learning_data$pop_size,
  prediction = model_rf$model.rf$predictions
)

# Graphique ggplot
ggplot(prediction_df, aes(x = pop_size, y = prediction)) +
  geom_point(shape = 1, alpha = 0.6) +  # cercles ouverts et transparence
  geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed") +  # ligne identité
  labs(
    x = "True value (pop_size)",
    y = "Predicted value",
    title = "Prediction vs True values (abcrf)"
  ) +
  theme_minimal()

```

