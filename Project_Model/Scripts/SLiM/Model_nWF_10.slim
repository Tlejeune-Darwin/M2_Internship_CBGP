initialize() {
    defineConstant("popSize", 200);     // Taille de la population
    defineConstant("generations", 10);  // Nombre de gÃ©nÃ©rations
    defineConstant("sampleSize", 20);   // Nombre d'individus Ã  Ã©chantillonner

    initializeSLiMModelType("nonWF");   // ModÃ¨le Non Wright-Fisher
    initializeMutationRate(0);
    initializeMutationType("m1", 0.5, "f", 0.0);
    initializeGenomicElementType("g1", m1, 9);
    initializeGenomicElement(g1, 0, 9);
    initializeRecombinationRate(0.5);

    // ğŸ”¹ Initialisation correcte de lâ€™enregistrement des arbres
    initializeTreeSeq(retainCoalescentOnly=F);
}

1 early() {
    catn("ğŸ”¹ Simulation started with seed: " + getSeed());
    sim.addSubpop("p1", popSize); // ğŸ”¹ CrÃ©ation de la population
}

1 late() {
    catn("ğŸ”¹ SÃ©lection et enregistrement des individus de la 1Ã¨re gÃ©nÃ©ration :");

    // ğŸ”¹ VÃ©rifier qu'on a bien des individus disponibles
    if (size(p1.individuals) >= sampleSize) {
        sampled_first_gen = sample(p1.individuals, sampleSize, replace=F);

        // ğŸ”¹ Marquer ces individus comme "Remembered" (permanent)
        for (ind in sampled_first_gen) {
            sim.treeSeqRememberIndividuals(ind, permanent=T);
        }

        catn("  â Individus retenus (Remembered - 1Ã¨re gÃ©nÃ©ration) : "); 
		  catn(sampled_first_gen);
    } else {
        catn("âš ï¸ Pas assez d'individus pour l'Ã©chantillonnage de la 1Ã¨re gÃ©nÃ©ration !");
    }
}

reproduction() {
    K = popSize;
    parents1 = p1.sampleIndividuals(K, replace=F);
    parents2 = p1.sampleIndividuals(K, replace=F);

    for (i in seqLen(K))
        p1.addCrossed(parents1[i], parents2[i]);

    self.active = 0;
}

early() {
    // ğŸ”¹ Supprime les individus Ã¢gÃ©s pour Ã©viter la surpopulation
    inds = p1.individuals;
    inds[inds.age > 0].fitnessScaling = 0.0;
}

9 late() {
    catn("ğŸ”¹ SÃ©lection et enregistrement des individus de la derniÃ¨re gÃ©nÃ©ration :");

    // ğŸ”¹ VÃ©rifier qu'on a bien des individus disponibles
    if (size(p1.individuals) >= sampleSize) {
        sampled_last_gen = sample(p1.individuals, sampleSize, replace=F);

        // ğŸ”¹ Marquer ces individus comme "Retained" (temporaire)
        for (ind in sampled_last_gen) {
            sim.treeSeqRememberIndividuals(ind, permanent=F);
        }

        catn("  â Individus retenus (Retained - DerniÃ¨re gÃ©nÃ©ration) : ");
		  catn(sampled_last_gen);
    } else {
        catn("âš ï¸ Pas assez d'individus pour l'Ã©chantillonnage de la derniÃ¨re gÃ©nÃ©ration !");
    }

    // ğŸ”¹ Assurer que le dossier output_trees existe
    system("mkdir -p output_trees");

    // ğŸ”¹ Sauvegarde du fichier .trees
    sim.treeSeqOutput("C:/Users/poupe/OneDrive/Bureau/Dossier_cours/M2_Semestre_1/Stage/SLiM/Models/output_trees/simulation.trees");
    catn("âœ… DonnÃ©es enregistrÃ©es dans : output_trees/simulation.trees");
}
